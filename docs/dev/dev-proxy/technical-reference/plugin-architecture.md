---
title: Plugin architecture
description: The architecture of Dev Proxy plugins
author: garrytrinder
ms.author: garrytrinder
ms.date: 01/13/2026
---

<!-- INTENT: Understand how Dev Proxy plugins work (intercepting, reporting, reporters, stdio) -->

# Plugin architecture

A plugin is a .NET class registered with Dev Proxy that introduces a specific Dev Proxy behavior. A plugin can offer real-time guidance about API usage, simulate API behavior, analyze multiple API requests, or produce a report. Dev Proxy has four types of plugins:

- **intercepting plugins** that intercept HTTP requests and responses and can analyze and modify them
- **STDIO plugins** that intercept stdin/stdout/stderr communication with local executables
- **reporting plugins** that run on requests [recorded](../how-to/record-and-export-proxy-activity.md) by Dev Proxy
- **reporters** that generate reports based on the data collected by reporting plugins

You register plugins in the [`devproxyrc.json` file](devproxyrc.md). The file contains a list of plugins to load and their configuration.

Dev Proxy comes with a [collection of plugins](overview.md#plugins) and you can [create custom plugins](../how-to/create-custom-plugin.md) to extend Dev Proxy functionality to match your needs.

When Dev Proxy starts, it loads plugins enabled in its configuration file. Depending which plugins you enable, Dev Proxy can provide guidance, simulate API behavior, or analyze API requests. Following sections explain how the different types of plugins work.

## Intercepting plugins

When Dev Proxy intercepts a request matching one of the URLs in the `urlsToWatch` array, it invokes each intercepting plugin in the order they're listed in the configuration file. Each intercepting plugin inherits from the [`BaseProxyPlugin`](https://github.com/dotnet/dev-proxy/blob/main/dev-proxy-abstractions/BaseProxyPlugin.cs) class, and can subscribe to the following events:

- `BeforeRequest` - raised when Dev Proxy intercepts a request
- `BeforeResponse` - raised after Dev Proxy receives a response from the server
- `AfterResponse` - raised after Dev Proxy sends the response to the client

For each of these events, plugins can define an event handler. In the handler, the plugin can analyze the request and response, and modify it if needed. It can also output guidance messages. To see what's possible, see the [code of plugins provided with Dev Proxy](https://github.com/dotnet/dev-proxy/tree/main/dev-proxy-plugins).

## STDIO plugins

When you use the [`stdio` command](stdio.md), Dev Proxy proxies STDIN/STDOUT/STDERR communication with local executables. Proxying STDIO is useful for testing and debugging Model Context Protocol (MCP) servers and other STDIO-based applications.

STDIO plugins implement the `IStdioPlugin` interface and can subscribe to the following events:

- `BeforeStdinAsync` - raised before forwarding STDIN to the child process
- `AfterStdoutAsync` - raised after receiving STDOUT from the child process
- `AfterStderrAsync` - raised after receiving STDERR from the child process
- `AfterStdioRequestLogAsync` - raised to log and record STDIO request/response pairs
- `AfterStdioRecordingStopAsync` - raised when the session ends to process recordings

Plugins can modify, consume, or mock messages by setting `ResponseState.HasBeenSet = true`. The following plugins support STDIO interception:

- [MockStdioResponsePlugin](mockstdioresponseplugin.md) - mock STDIN/STDOUT/STDERR responses
- [DevToolsPlugin](devtoolsplugin.md) - inspect STDIO traffic in Chrome DevTools
- [LatencyPlugin](latencyplugin.md) - add artificial latency to STDIO communication

## Reporting plugins

Dev Proxy allows you to record API requests and responses. You typically use recording to report on API usage or analyze multiple API requests. Reporting plugins inherit from the `BaseReportingPlugin` class, and register an event handler with the `AfterRecordingStop` event.

When you stop recording, Dev Proxy raises the `AfterRecordingStop` event, passing the list of recorded requests and responses as an argument to the registered event handlers. Reporting plugins can then analyze the recorded data and generate a report object. A report object is an arbitrary object defined by the reporting plugin. Reporting plugins store the reports by calling the [`StoreReport`](https://github.com/dotnet/dev-proxy/blob/ecb4e1d56e327204f359152f7aff1057663edfe6/dev-proxy-abstractions/BaseReportingPlugin.cs#L15) method.

> [!IMPORTANT]
> Reporting plugins generate report objects, which Dev Proxy stores in memory. To convert these report objects into user-readable reports, you must enable one or more reporters in the Dev Proxy configuration file.

## Reporters

Dev Proxy uses [reporters](./overview.md#reporters) to convert report objects generated by reporting plugins into user-readable reports. For example, the [MarkdownReporter](./markdownreporter.md) converts a report object into a Markdown file. Reporters are special plugins that inherit from the [`BaseReporter`](https://github.com/dotnet/dev-proxy/blob/main/dev-proxy-plugins/Reporters/BaseReporter.cs) class. They implement the [`GetReport`](https://github.com/dotnet/dev-proxy/blob/ecb4e1d56e327204f359152f7aff1057663edfe6/dev-proxy-plugins/Reporters/BaseReporter.cs#L25) method, which takes as argument a report created by a reporting plugin and converts it into a string. This string is then saved on disk following the `PluginName_ReporterName.ReporterExtension` pattern, for example: `ApiCenterOnboardingPlugin_MarkdownReporter.md`.

> [!IMPORTANT]
> Because reporters depend on the report objects generated by reporting plugins, you must enable the reporting plugins in the Dev Proxy configuration file after reporting plugins. If you enable them before reporting plugins, reporters won't have any data to report on.
